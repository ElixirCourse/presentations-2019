---
## Pattern matching и управляващи оператори

---
![Image-Absolute](assets/basics.jpg)

---
## Да си преговорим!

 * Правим си проекти с mix
 * Програмите ни са модули, които съдържат функции

---
## Основни типове
![Image-Absolute](assets/types.png)

---
### Числа

```elixir
1 # В десетична бройна система
#=> 1
10_000
#=> 10000
0x53 # В шестнадесетична
#=> 83
0o53  # В осмична
#=> 43
0b11 # В двоична
#=> 3
3.14 # С плаваща запетая
#=> 3.14
1.0e-10 # С плаваща запетая
#=> 1.0e-10
```

---
```elixir
1 + 41
#=> 42
21 * 2
#=> 42
54 / 6 # Връща резултат с плаваща запетая
#=> 9.0
Kernel.div(54, 6) # В повечето езици `/` прави това
#=> 9
Kernel.rem 11, 3 # А ето как получаваме остатъка.
#=> 2
```

---
```elixir
1 < 2
#=> true
1 >= 1
#=> true
1 != 2
#=> true
1 == 2
#=> false
1 == 1.0 # Операторът == сравнява по стойност
#=> true
1 === 1.0 # Операторът === сравнява по стойност И тип
#=> false
1 !== 1.0 # Операторът !== сравнява по стойност И тип
#=> true
```

---
### Булеви стойности: true/false

```elixir
true
#=> true
false
#=> false
Kernel.is_boolean(true)
#=> true
is_boolean(0)
#=> false
true == false
#=> false
```

---
### Атоми
* Атомите са константи, чието име е стойността им.
* Булевите стойности `true` и `false` всъщност са атомите `:true` и `:false`
* Имената на модули (колекции от функции и нещо повече) в Elixir също са атоми.
* Модули идващи от Erlang са реферирани от атоми.
* GC не ги събира.

---
### Атоми
* Удобни са за ползване като ключове в `map`-ове.
* Задължителна част от `keyword lists`.
* Често се използват в tuple-и за означаване на резултат от функция. Пример - ``{:ok, 2}``

---
### Атоми
* Освен ако не са в двойни кавички, атомите могат да съдържат подчертавки, цифри и латински букви, както и at(`@`).
* Атомите могат да завършват на `!` или на `?`.
* Идеални за pattern matching (съпоставянето им е еквивалентно на съпоставяне на числа)

---
```elixir
:atom
#=> :atom
:true
#=> true
SomeModule # Може и да не е дефиниран
#=> SomeModule
is_atom(:atom)
#=> true
is_atom(true)
#=> true
true == :true
#=> true
:"atom with a space" # Могат да се дефинират и така
#=> :"atom with a space"
```

---
### Низове
Низовете в `Elixir` се дефинират с двойни кавички и са с _UTF-8_ encoding:

---
```elixir
#=> "Здрасти"
"Здрасти"
#=> "Здрасти #{:Danchou}" # Интерполация
"Здрасти Danchou"
```

---
```elixir
is_binary("Здрасти")
#=> true
String.length("Здрасти") # Брой на символи
#=> 7
byte_size("Здрасти") # Брой на байтове
#=> 14
"Бял" <> " мерцедес!" # Конкатенация
#=> "Бял мерцедес!"
```

---
### Списъци
* Има специален модул, `List`, за работа с тях.
* Не държат стойностите си подредени в паметта.
* Намирането на дължината им, четене на стойност по index, добавяне на стойност на index и триене на стойност на index са все линейни операции.

---
```elixir
[1, 2, "три", 4.0] # Не са хомогенни
#=> [1, 2, "три", 4.0]
length [1, 2, 3, 5, 8] # Дължината
#=> 5
hd [1, 2, 3, 5, 8]
#=> 1
tl [1, 2, 3, 5, 8]
#=> [2, 3, 5, 8]
is_list([1, 2])
#=> true
'Еликсир' # Списък от unicode codepoint-и
#=> [1045, 1083, 1080, 1082, 1089, 1080, 1088]
[83, 79, 83]
#=> 'SOS'
```

---
### Кортежи
![Image-Absolute](assets/tuple.jpg)

---
### Кортежи
* Кортежите съхраняват елементите си подредени един след друг в паметта.
* Достъпът до елемент по индекс и взимането на дължината им са константни операции.

---
### Кортежи
* Заедно с атомите за връщане на множество стойности от функция.
* За `pattern matching` - ще видим малко по-долу.
* Read-only колекция, защото писането в тях е скъпа операция.

---
```elixir
{:ok, 7}
#=> {:ok, 7}
tuple_size({:ok, 7, 5})
#=> 3
is_tuple({:ok, 7, 5})
#=> true
```

---
### Keyword lists
Списъци, които съдържат `tuple`-и от по два елемента - атом и каквато и да е стойност.

---
```elixir
[{:one, 1}, {:two, 2}]
#=> [one: 1, two: 2]
[one: 1, two: 2]
#=> [one: 1, two: 2]
```

---
* Ако keyword list е последен аргумент на функция, можем да пропуснем квадратните скоби при извикване:
```elixir
f(1, 2, three: 3, four: 4)
```

---
* Ключовете им могат да се повтарят.
* Използват се и за предаване на command line параметри или опции на функции.
* Пример е `String.split/3`.
```elixir
String.split("one,two,,,three,,,four", ",", trim: true)
#=> ["one", "two", "three", "four"]
```

---
### Maps
* Колекции от ключове и стойности.
* `Map`-овете в `Elixir` не позволяват еднакви ключове.
* За ключове може да се използва всичко и дори няма нужда да бъдат един и същи тип,
но обикновено се използват низове или атоми.

---
### Бинарен тип (Binaries)
Прдставляват поредици от битове и байтове.
```elixir
<< 2 >> # Цялото число 2 в 1 байт
#=> <<2>>
byte_size << 2 >>
#=> 1
<< 255 >> # Цялото число 255 в 1 байт
#=> <<255>>
<< 256 >> # Превърта и става 0
#=> <<0>>
<<1, 2>> # Две цели числа в два байта.
#=> <<1, 2>>
byte_size << 1, 2 >>
#=> 2
```

---
```elixir
<< 5::size(3), 1::size(1), 5::size(4) >>
#=> <<181>>
0b10110101
#=> 181
byte_size << 5::size(3), 1::size(1), 5::size(4) >>
#=> 1
is_bitstring << 5::size(3), 1::size(1) >>
#=> true
is_binary << 5::size(3), 1::size(1) >>
#=> false
```

---
* Интересен факт - низовете в `Elixir` са имплементирани като `binary` тип.
* Спомняте си че `is_binary("Стринг")` връщаше `true`.
```elixir
<<208, 170, 208, 156>> = "ЪМ"
#=> "ЪМ"
```

---
### Анонимни функции
```elixir
fn (x) -> x + 1 end
#=> #Function<6.52032458/1 in :erl_eval.expr/5>
(fn (x) -> x + 1 end).(4) # Извикване
#=> 5
is_function((fn (x) -> x + 1 end))
#=> true
```

---
```elixir
&(&1 + 1)
#=> #Function<6.52032458/1 in :erl_eval.expr/5>
(&(&1 + 1)).(4)
#=> 5
```

---
### Други типове
* Други типове са `Port`, `Reference` и `PID`, които се използват с процеси.
* Има и регулярни изрази. `~r/\w+/im`
* Ranges : `(1..1000)`
* Има различни shortcut-синтаксиси за дефиниране на някои от типовете.

---
## Съпоставяне на образци
![Image-Absolute](assets/patterns.jpg)

---
## Съпоставяне на образци
* В Elixir `pattern matching`-ът е еднa от най-важните и основни особености.
* Операторът `=` се нарича `match operator`.
* Можем да го сравним с знака `=` в математиката.

---
## Съпоставяне на образци
* Използвайки го, превръщаме целия израз в уравнение, в което сравняваме лявата с дясната страна.
* Ако сравнението е успешно се връща стойността на това уравнение, ако не - има грешка.

---
```elixir
x = 5
#=> 5
5 = x
#=> 5
4 = x
#=> ** (MatchError) no match of right hand side value: 1

```

---
Засега за match operator-а знаем:
1. С него могат да се дефинират променливи.
2. С него могат да се правят проверки - дали дадена променлива има дадена стойност.

---
* Имената на променливи задължително започват с малка латинска буква или подчертавка (`_`),
следвана от букви, цифри или подчертавки.
* Могат да завършват на `?` или `!`.
* Операторът `=` ще опита да присвои на всички възможни променливи от ляво стойности от дясно.

---
```elixir
{one, tWo, t3, f_our, five!} = {1, 2, 3, 4, 5}
#=> {1, 2, 3, 4, 5}
one
#=> 1
tWo
#=> 2
t3
#=> 3
f_our
#=> 4
five!
#=> 5
```

---
```elixir
[head | tail] = [1, 2, 4, 5]
#=> [1, 2, 4, 5]
head
#=> 1
tail
#=> [2, 4, 5]
[a, b | tail] = [1, 2, 4, 5]
#=> [1, 2, 4, 5]
a
#=> 1
b
#=> 2
tail
#=> [4, 5]
```

---
```elixir
g = fn
  0 -> 0
  x -> x - 1
end
#=> #Function<6.52032458/1 in :erl_eval.expr/5>
g.(0)
#=> 0
g.(3)
#=> 2
```

---
![Image-Absolute](assets/pins.jpg)

---
* В `Elixir` e възможно да променим стойността на променлива (не точно, но shadows!).
* В `Erlang` това не е възможно.

---
Ако искаме една променлива, която вече съществува да не промени стойността си при съпоставяне,
можем да използваме `pin` оператора - `^`.
```elixir
x = 5
#=> 5
^x = 6
#=> ** (MatchError) no match of right hand side value: 6
```

---
```elixir
{y, ^x} = {5, 4}
```

---
Ако се опитаме да присвоим стойност на `unbound` променлива (досега не е съществувала),
използвайки `pin` оператора, ще получим грешка.
```elixir
^z = 4
#=> ** (CompileError) iex:56: unbound variable ^z
```

---
#### Параметри на функции

```elixir
defmodule Example do
  def factorial(0), do: 1
  def factorial(n), do: n * factorial(n - 1)
end
```

---
#### Гардове

```elixir
defmodule Questionnaire do
  def how_old_are_you?(age) when age > 30 do
    "Имаме си чичко или леличка"
  end
  def how_old_are_you?(age) when age > 20 do
    "Имаме си милениалче, тригърнато от живота"
  end
  def how_old_are_you?(_), do: "Дете"
end

Questionnaire.how_old_are_you?(21)
#=> "Имаме си милениалче, тригърнато от живота"
```

---
## Control Flow
![Image-Absolute](assets/control_flow.jpg)

---
#### if / unless

```elixir
defmodule Questionnaire do
  def how_old_are_you?(age) do
    if age > 30 do
      "Имаме си чичко или леличка"
    else
      if age > 20 do
        "Имаме си милениалче, тригърнато от живота"
      else
        "Дете"
      end
    end
  end
end
```

---
* Наше мнение е, че if е напълно ненужна конструкция в Elixir.
* Но има и още една, още по-ненужна - unless. |

---
Стойността на `if` или на `unless` е стойността на израза, който се оценява.

```elixir
age = 34
name = "Слави"

if age < 30 do
  "Младеж"
end
#=> nil

if age > 30, do: "Чичо #{name}", else: name
#=> "Чичо Слави"
```

---
### Cond
![Image-Absolute](assets/cond.png)

---
```elixir
defmodule FizzBuzz do
  def of(n), do: Enum.map(1..n, &number_value/1)

  defp number_value(n) do
    cond do
      rem(n, 3) == 0 and rem(n, 5) == 0 -> "FizzBuzz"
      rem(n, 3) == 0 -> "Fizz"
      rem(n, 5) == 0 -> "Buzz"
      true -> n
    end
  end
end
```

---
* В 'cond' слагаме списък от условия, със свързан с тях код.
* Оценяват се докато стигнем до някое, което се оцени като true. |
* Когато това стане, се изпълнява асоциираният с него код и това е стойността на cond-a. |


---
* Обикновено последното условие на cond е 'true', за да има код, който да се изпълни,
* Ако не го сложим и нищо не се оцени като истина ще има грешка.

---
#### Специални форми
* За разлика от if, cond е 'специална форма'.
* Специалните форми са най-базовите градивни единици в Elixir.  |
* Не могат да се пренапишат от нас.  |
* Те са специални macro-си, които не са на написани на езика.  |

---
* Конструкциите if и unless са добавени за да се справи един императивен програмист с навлизането в Elixir.
* Според нас са повече вредни, отколкото помагат. |
* Забравете че ги има. |
* Всъщност забравете и за cond.  |

---
### Case
![Image-Absolute](assets/case.jpg)


---
```elixir
defmodule Questionnaire do
  def asl(age, sex, location) do
    case sex do
      :male ->
        "#{age}, М, #{location}"
      :female ->
        "#{age}, F, #{location}"
      _ ->
        "#{age}, LGBT, #{location}"
    end
  end
end
```

---
* Нужна е последна клауза, която match-ва всякакви стойности.
* Ако нищо не се match-не се изпълнява тази последна клауза.
* Ако я няма ще имаме грешка (CaseClauseError).

---
* Важно е да знаем, че case, също като cond е специална форма.
* Ползваме го само ако кодът ни стане прекалено разхвърлян или труден за разбиране с функции pattern matching. |
* Забравете за if и unless, по добре използвайте case. |

---
Защо case е по-добър избор пред cond?

* Проверките които правим в case, са свързани с data-та която му даваме.
* Лесно можем да съобразим какво и защо проверяваме. |
* По-трудно да вкараме странични ефекти. |

---
* Проверките в cond могат да са всякакви и да са свързани с всякакви данни.
* Много по-лесно е да напишем код, в който се чудим кое от къде идва. |
* Много по-лесно е да имаме странични ефекти. |

---
### В заключение - докато трае курса if, unless и cond не съществуват.

---
### Конструкцията with
![Image-Absolute](assets/with.jpg)

---
* Още една специална форма, която опростява писането на код.
* Това, което прави with е да комбинира множество успешни съпоставяния.
* Ако искаме няколко различни условия да са изпълнени за да направим нещо и ако само едно от тези условия не е изпълнено, да не го правим.

---
```elixir
defmodule HR do
  def work_experience(years) when years > 10, do: :experienced
  def work_experience(years) when years > 5, do: :advanced
  def work_experience(_), do: :not_experienced

  def knows_elixir?([]), do: false
  def knows_elixir?([:elixir, _]), do: true
  def knows_elixir?([_ | rest]), do: knows_elixir?(rest)

  def read_cv(file_path), do: File.read(file_path)
end
```

---

```elixir
years = 11
#=> 11

languages = [:erlang, :elixir, :rust]
#=> [:erlang, :elixir, :rust]

cv_path = "/tmp/cv.txt"

with :experienced <- HR.work_experience(years),
     true <- HR.knows_elixir?(languages),
     {:ok, cv} <- HR.read_cv(cv_path),
     do: cv
#=> "Some CV\n
```


---
Ако някое от условията не е изпълнено, ще получим стойността му:

```elixir
with :experienced <- HR.work_experience(3),
     true <- HR.knows_elixir?(languages),
     {:ok, cv} <- HR.read_cv(cv_path),
     do: cv
#=> :not_experienced
```

---
* Можем да правим още неща с with - погледнете документацията
* Погледнете и другите специални форми!

---
## Неизменимост
![Image-Absolute](assets/immutable.png)

---
```elixir
base_list = [1, 2, 3]
#=> [1, 2, 3]
new_list = [0 | base_list]
#=> [0, 1, 2, 3]
```

---
## Това беше за днес.
![Image-Absolute](assets/end.jpg)
